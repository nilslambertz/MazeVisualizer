{"version":3,"sources":["Components/Content/Main.js","Components/Navigation/NavBar.js","Components/Settings/SettingsBar.js","Utils/Functions.js","Algorithms/Dfs.js","Algorithms/Dijkstra.js","Algorithms/Tremaux.js","Algorithms/GreedySearch.js","Algorithms/AStar.js","App.js","Utils/Animation.js","serviceWorker.js","index.js"],"names":["Main","className","this","props","algorithm","solved","id","printMaze","steps","maze","map","c","i","a","c2","i2","a2","key","width","left","right","top","style","borderBottom","bottom","borderLeft","borderTop","borderRight","React","Component","NavBar","algorithmList","setAlgorithm","animationRunning","onClick","algo","SettingsBar","animationSpeed","newMazeClick","animationClick","changeSpeed","perfectMaze","setPerfectMaze","perfectMazeStyle","color","rowSpan","type","min","max","value","onChange","createMaze","height","j","walls","remainingWalls","Set","length","add","firstX","Math","floor","random","firstY","addWalls","delete","size","getRandomItem","x","parseInt","substring","indexOf","y","neighbours","getNeighbours","randomNeighbour","splice","createPath","primsAlgorithm","n","elem","getPathNeighbours","startX","startY","endX","endY","start","end","x1","y1","x2","y2","push","set","items","Array","from","wasHere","path","count","getPathRecursive","parent","dfs","getDfsSteps","m","s","e","shift","pop","queue","marks","lastX","lastY","stack","PriorityQueue","require","getDijkstra","b","distance","enq","isEmpty","deq","undefined","dijkstra","neverBeenHere","currX","currY","ignoreX","ignoreY","getMarks","curr","mark","markJunctionEnter","markedX","markedY","markCount","Object","assign","junctionX","junctionY","getTremaux","found","next","removeIndex","tempX","tempY","minMarks","minElem","temp","console","log","tremaux","getGreedy","abs","sort","greedySearch","getDistance","getAStar","heuristic","h","aStar","animation","Animation","setState","addCountFunction","getAlgorithmTitles","keys","pathStepBack","pathNumber","pathStepFront","defaultStep","addCount","arrayStep","arr","tremauxStep","lastArr","lastElem","first","last","speed","getSteps","step","changeAlgorithm","getStepFunction","pathFunction","stepFunction","stepCount","saveMaze","animate","alert","values","slice","finished","pathFunc","clearInterval","interval","animatePath","pathAnimating","func","int","setInterval","endAnimation","App","state","setStart","setEnd","newSpeed","parseFloat","target","changeMaze","changeState","v","startAnimation","addToStepCount","algos","changeSize","href","rel","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.fa18dc9a.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Main.css';\r\nimport \"./MazeElem.css\";\r\n\r\nclass Main extends React.Component {\r\n    render() {\r\n        let className = \"transition\";\r\n        if(this.props.algorithm === \"tremaux\") {\r\n            className = \"noTransition\";\r\n        }\r\n        if(this.props.solved === true) className += \" solved\";\r\n        return (\r\n            <div id=\"mainDiv\" className={className}>\r\n                <div id=\"mazeGrid\">\r\n                    {this.printMaze()}\r\n                    <div id=\"stepCountDiv\">steps: {this.props.steps}</div>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    printMaze() {\r\n        return this.props.maze.map(function(c, i, a) {\r\n            return c.map(function(c2, i2, a2) {\r\n                if(c2 === 0) {\r\n                    return <div className={\"mazeElem empty\"} key={i+i2}/>;\r\n                } else if(c2 === 1) {\r\n                    return <div className={\"mazeElem wall\"} key={i+i2}/>;\r\n                } else if(c2 === 2) {\r\n                    return <div className={\"mazeElem start\"} key={i+i2}/>;\r\n                } else if(c2 === 3) {\r\n                    return <div className={\"mazeElem end\"} key={i+i2}/>\r\n                } else if(c2 === 4) {\r\n                    return <div className={\"mazeElem searched\"} key={i+i2}/>;\r\n                } else if(c2 === 5) {\r\n                    return <div className={\"mazeElem correctPath\"} key={i+i2}/>;\r\n                } else {\r\n                    let width = \"2px solid \";\r\n                    let left = c2.left > 0 ? (c2.left > 1 ? \"red\" : \"orange\") : \"none\";\r\n                    let right = c2.right > 0 ? (c2.right > 1 ? \"red\" : \"orange\") : \"none\";\r\n                    let top = c2.top > 0 ? (c2.top > 1 ? \"red\" : \"orange\") : \"none\";\r\n                    let bottom = c2.bottom > 0 ? (c2.bottom > 1 ? \"red\" : \"orange\") : \"none\";\r\n                    let style = {\r\n                        borderBottom: width + bottom,\r\n                        borderLeft: width + left,\r\n                        borderTop: width + top,\r\n                        borderRight: width + right\r\n                    }\r\n                    return <div className={\"mazeElem empty\"} style={style} key={i+i2}/>;\r\n                }\r\n            })\r\n        });\r\n    }\r\n}\r\n\r\nexport default Main;\r\n","import React from 'react';\r\nimport './NavBar.css';\r\n\r\nfunction NavBar({algorithmList, algorithm, setAlgorithm, animationRunning}) {\r\n\r\n    function changeAlgorithm(algo) {\r\n        if(animationRunning) return;\r\n\r\n        setAlgorithm(algo);\r\n    }\r\n\r\n    return (\r\n        <div id=\"navbar\">\r\n            {algorithmList.map(function(c, i, a) {\r\n                let className = \"navElem\";\r\n                if(c === algorithm) {\r\n                    className += \" active\";\r\n                } else if (animationRunning) {\r\n                    className += \" disabled\"\r\n                }\r\n                return <div key={c} className={className} onClick={() => changeAlgorithm(c)}>{c}</div>;\r\n            })}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default NavBar;\r\n","import React from 'react';\r\nimport './SettingsBar.css';\r\n\r\nfunction SettingsBar({solved, animationRunning, animationSpeed, newMazeClick, animationClick, changeSpeed, perfectMaze, setPerfectMaze}) {\r\n    const playStyle = {\r\n        color: \"lightgreen\"\r\n    }\r\n    const stopStyle = {\r\n        color: \"orange\"\r\n    }\r\n\r\n    let perfectMazeStyle = {\r\n        color: perfectMaze ? \"#62D40C\" : \"#E98A45\"\r\n    }\r\n\r\n    return (\r\n        <div id=\"settingsBar\">\r\n            <div id=\"settingsDiv\">\r\n                <table>\r\n                    <tbody>\r\n                    <tr>\r\n                        <td className={\"settingsButton\" + (solved ? \" noClickSetting\" : \"\")} rowSpan=\"2\" style={animationRunning ? stopStyle : playStyle} onClick={animationClick}>\r\n                            {animationRunning ? \"stop\" : \"start\"}\r\n                        </td>\r\n                    </tr>\r\n                    </tbody>\r\n                </table>\r\n                <table className={(animationRunning ? \"disabledSetting\" : \"\")}>\r\n                    <tbody>\r\n                    <tr>\r\n                        <td id=\"newMaze\" className=\"settingsButton\" rowSpan=\"2\" onClick={newMazeClick}>\r\n                            new maze\r\n                        </td>\r\n                    </tr>\r\n                    </tbody>\r\n                </table>\r\n                <table className={(animationRunning ? \"disabledSetting\" : \"\")}>\r\n                    <tbody>\r\n                    <tr>\r\n                        <td id=\"perfectMaze\" style={perfectMazeStyle} className=\"settingsButton\" rowSpan=\"2\" onClick={() => {\r\n                            if(animationRunning) return;\r\n                            setPerfectMaze(!perfectMaze)\r\n                        }}>\r\n                            perfect maze: {perfectMaze ? \"✅\" : \"❌\"}\r\n                        </td>\r\n                    </tr>\r\n                    </tbody>\r\n                </table>\r\n                {<table className={(animationRunning ? \"disabledSetting\" : \"\")}>\r\n                    <tbody>\r\n                    <tr>\r\n                        <td>\r\n                            <input type=\"range\" min=\"10\" max=\"500\" value={animationSpeed} onChange={changeSpeed}/>\r\n                        </td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>\r\n                            animation speed\r\n                        </td>\r\n                    </tr>\r\n                    </tbody>\r\n                </table>}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SettingsBar;\r\n","export const createMaze = (height, width, perfectMaze) => {\r\n    let maze = [];\r\n    for(let i = 0; i < height; i++) {\r\n        maze[i] = [];\r\n        for(let j = 0; j < width; j++) {\r\n            maze[i][j] = 1;\r\n        }\r\n    }\r\n\r\n    let walls = primsAlgorithm(maze);\r\n\r\n    if(!perfectMaze) {\r\n        let max = 100;\r\n        for(let n = 0; n < max; n++) {\r\n            let elem = getRandomItem(walls);\r\n            let i = parseInt(elem.substring(0, elem.indexOf(\",\")));\r\n            let j = parseInt(elem.substring(elem.indexOf(\",\") + 1));\r\n\r\n            let neighbours = getPathNeighbours(maze, i, j);\r\n            if(neighbours.length !== 2) continue;\r\n\r\n            let x = neighbours[0].x - neighbours[1].x;\r\n            let y = neighbours[0].y - neighbours[1].y;\r\n\r\n            if(y === 0) {\r\n                maze[i][j] = 0;\r\n            } else if(x === 0) {\r\n                maze[i][j] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    let startX = Math.floor(Math.random() * maze.length);\r\n    let startY = Math.floor(Math.random() * maze[0].length);\r\n    while(maze[startX][startY] !== 0) {\r\n        startX = Math.floor(Math.random() * maze.length);\r\n        startY = Math.floor(Math.random() * maze[0].length);\r\n    }\r\n    maze[startX][startY] = 2;\r\n\r\n    let endX = Math.floor(Math.random() * maze.length);\r\n    let endY = Math.floor(Math.random() * maze[0].length);\r\n    while(maze[endX][endY] !== 0 || (startX === endX && startY === endY)) {\r\n        endX = Math.floor(Math.random() * maze.length);\r\n        endY = Math.floor(Math.random() * maze[0].length);\r\n    }\r\n    maze[endX][endY] = 3;\r\n\r\n    return {\r\n        maze: maze,\r\n        start: [startX, startY],\r\n        end: [endX, endY]\r\n    };\r\n}\r\n\r\nfunction primsAlgorithm(maze) {\r\n    let remainingWalls = new Set();\r\n    for(let i = 0; i < maze.length; i++) {\r\n        for (let j = 0; j < maze[i].length; j++) {\r\n            remainingWalls.add(i + \",\" + j);\r\n        }\r\n    }\r\n\r\n    let walls = new Set();\r\n    let firstX = Math.floor(Math.random() * maze.length);\r\n    if(firstX % 2 === 1) firstX--;\r\n    let firstY = Math.floor(Math.random() * maze[0].length);\r\n    if(firstY % 2 === 1) firstY--;\r\n    addWalls(firstX,firstY, walls, remainingWalls, maze);\r\n    maze[firstX][firstY] = 0;\r\n    remainingWalls.delete(firstX + \",\" + firstY);\r\n    while(walls.size > 0) {\r\n        let random = getRandomItem(walls);\r\n        let x = parseInt(random.substring(0, random.indexOf(\",\")));\r\n        let y = parseInt(random.substring(random.indexOf(\",\") + 1));\r\n        let neighbours = getNeighbours(x, y, maze);\r\n        let randomNeighbour = neighbours.splice(Math.floor(Math.random() * neighbours.length), 1)[0];\r\n        createPath(x, y, randomNeighbour[0], randomNeighbour[1], maze, remainingWalls);\r\n        maze[x][y] = 0;\r\n        remainingWalls.delete(x + \",\" + y);\r\n        walls.delete(random);\r\n        addWalls(x, y, walls, remainingWalls, maze);\r\n    }\r\n\r\n    return remainingWalls;\r\n}\r\n\r\nfunction createPath(x1, y1, x2, y2, maze, remainingWalls) {\r\n    if(x1 === x2) {\r\n        if(y1 < y2) {\r\n            maze[x1][y1+1] = 0;\r\n            remainingWalls.delete(x1 + \",\" + (y1+1));\r\n        } else {\r\n            maze[x1][y1-1] = 0;\r\n            remainingWalls.delete(x1 + \",\" + (y1-1));\r\n        }\r\n    } else {\r\n        if(x1 < x2) {\r\n            maze[x1+1][y1] = 0;\r\n            remainingWalls.delete((x1+1) + \",\" + y1);\r\n        } else {\r\n            maze[x1-1][y1] = 0;\r\n            remainingWalls.delete((x1-1) + \",\" + y1);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getNeighbours(x,y, maze) {\r\n    let neighbours = [];\r\n    if(x-2 >= 0 && maze[x-2][y] === 0) {\r\n        neighbours.push([x-2, y]);\r\n    }\r\n    if(x+2 < maze.length && maze[x+2][y] === 0) {\r\n        neighbours.push([x+2, y]);\r\n    }\r\n    if(y-2 >= 0 && maze[x][y-2] === 0) {\r\n        neighbours.push([x, y-2]);\r\n    }\r\n    if(y+2 < maze[0].length && maze[x][y+2] === 0) {\r\n        neighbours.push([x, y+2]);\r\n    }\r\n    return neighbours;\r\n}\r\n\r\nfunction addWalls(x,y, walls, remainingWalls, maze) {\r\n    if(x-2 >= 0 && maze[x-2][y] !== 0) {\r\n        walls.add((x-2) + \",\" + y);\r\n    }\r\n    if(x+2 < maze.length && maze[x+2][y] !== 0) {\r\n        walls.add((x+2) + \",\" + y);\r\n    }\r\n    if(y-2 >= 0 && maze[x][y-2] !== 0) {\r\n        walls.add(x + \",\" + (y-2));\r\n    }\r\n    if(y+2 < maze[0].length && maze[x][y+2] !== 0) {\r\n        walls.add(x + \",\" + (y+2));\r\n    }\r\n}\r\n\r\nfunction getRandomItem(set) {\r\n    let items = Array.from(set);\r\n    return items[Math.floor(Math.random() * items.length)];\r\n}\r\n\r\nexport const getPathNeighbours = (maze, x, y) => {\r\n    let n = [];\r\n\r\n    if(x > 0 && maze[x-1][y] !== 1) {\r\n        n.push({\r\n            x: x-1,\r\n            y: y\r\n        });\r\n    }\r\n    if(x < maze.length-1 && maze[x+1][y] !== 1) {\r\n        n.push({\r\n            x: x+1,\r\n            y: y\r\n        });\r\n    }\r\n    if(y > 0 && maze[x][y-1] !== 1) {\r\n        n.push({\r\n            x: x,\r\n            y: y-1\r\n        });\r\n    }\r\n    if(y < maze[0].length-1 && maze[x][y+1] !== 1) {\r\n        n.push({\r\n            x: x,\r\n            y: y+1\r\n        });\r\n    }\r\n    return n;\r\n}\r\n\r\nexport function getPathRecursive(elem) {\r\n    let path = [];\r\n\r\n    // Until element before starting node is reached\r\n    while((elem = elem.parent).parent !== null) {\r\n        path.push(elem); // Push element to path\r\n    }\r\n    return path;\r\n}","import { getPathNeighbours } from \"../Utils/Functions\";\r\n\r\nlet steps;\r\nlet maze;\r\nlet wasHere;\r\nlet path;\r\nlet end;\r\nlet count;\r\n\r\nfunction dfs(x, y, c) {\r\n    // If at the destination, return true\r\n    if(x === end[0] && y === end[1]) return true;\r\n\r\n    // If already visited, start new step-iteration\r\n    if(wasHere[x][y] === true) {\r\n        if(c !== 0) steps[++count] = [];\r\n        return false;\r\n    }\r\n\r\n    // Adding current node to steps and marking it as visited\r\n    steps[count].push({x: x, y: y});\r\n    wasHere[x][y] = true;\r\n\r\n    // Get neighbours\r\n    let n = getPathNeighbours(maze, x, y);\r\n\r\n    // If at junction, start new \"step\" after this one\r\n    if(n.length > 2) {\r\n        steps[++count] = [];\r\n    }\r\n\r\n    // For every neighbour\r\n    for(let i = 0; i < n.length; i++) {\r\n        // Call dfs recursively, if we found the destination we push current node to path and return true\r\n        if(dfs(n[i].x, n[i].y, i) === true) {\r\n            path.push({x: x, y: y});\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Not correct path\r\n    return false;\r\n}\r\n\r\nfunction getDfsSteps(m, s, e) {\r\n    maze = m;\r\n    steps = [];\r\n    end = e;\r\n    wasHere = [];\r\n    path = [];\r\n    count = 0;\r\n    for(let i = 0; i < m.length; i++) {\r\n        wasHere[i] = [];\r\n        for(let j = 0; j < m[i].length; j++) {\r\n            wasHere[i][j] = false;\r\n        }\r\n    }\r\n    steps = [[]];\r\n    dfs(s[0],s[1], 0); // Start search\r\n    steps[0].shift(); // Remove first step (on starting node)\r\n    path.pop(); // Remove last node from path (destination)\r\n\r\n    // Return values\r\n    return {\r\n        steps: steps,\r\n        path: path\r\n    };\r\n}\r\n\r\nexport { getDfsSteps };","import {getPathNeighbours, getPathRecursive} from \"../Utils/Functions\";\r\n\r\nlet PriorityQueue = require('priorityqueuejs'); // Using PriorityQueue\r\n\r\nlet steps;\r\nlet maze;\r\nlet wasHere;\r\nlet queue;\r\nlet path;\r\nlet end;\r\n\r\n// Dijkstra's algorithm\r\nfunction dijkstra() {\r\n    // While more elements are in the queue\r\n    while(!queue.isEmpty()) {\r\n        let elem = queue.deq(); // Get first element\r\n        if(wasHere[elem.x][elem.y] === true) continue; // Continue, if already visisted\r\n\r\n        wasHere[elem.x][elem.y] = true; // Set visisted\r\n\r\n        // If at destination\r\n        if(elem.x === end[0] && elem.y === end[1]) {\r\n            path = getPathRecursive(elem); // Get path\r\n            return;\r\n        }\r\n\r\n        // Create array if in new step, add current element to step\r\n        if(steps[elem.distance] === undefined) steps[elem.distance] = [];\r\n        steps[elem.distance].push(elem);\r\n\r\n        let neighbours = getPathNeighbours(maze, elem.x, elem.y); // Get neighbours\r\n\r\n        // For all neighbours\r\n        for(let n of neighbours) {\r\n            if(wasHere[n.x][n.y] === true) continue; // Continue, if visited\r\n\r\n            // Set new distance and current element as parent and enqueue the neighbour\r\n            n.distance = elem.distance + 1;\r\n            n.parent = elem;\r\n            queue.enq(n);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getDijkstra(m, s, e) {\r\n    maze = m;\r\n    steps = [];\r\n    end = e;\r\n    wasHere = [];\r\n    path = [];\r\n    for (let i = 0; i < m.length; i++) {\r\n        wasHere[i] = [];\r\n        for (let j = 0; j < m[i].length; j++) {\r\n            wasHere[i][j] = false;\r\n        }\r\n    }\r\n\r\n    // Initialize PriorityQueue, element with smallest distance is at the front\r\n    queue = new PriorityQueue(function(a, b) {\r\n        return b.distance - a.distance;\r\n    });\r\n\r\n    queue.enq({x: s[0], y: s[1], distance: 0, parent: null}); // Enqueue first element\r\n\r\n    dijkstra(); // Start search\r\n\r\n    // Remove starting-node from steps\r\n    steps.shift();\r\n\r\n    // Return values\r\n    return {\r\n        steps: steps,\r\n        path: path\r\n    };\r\n}\r\n\r\nexport { getDijkstra };","import {getPathNeighbours} from \"../Utils/Functions\";\r\n\r\nlet steps;\r\nlet maze;\r\nlet marks;\r\nlet path;\r\nlet count;\r\nlet x;\r\nlet y;\r\nlet lastX;\r\nlet lastY;\r\nlet start;\r\nlet end;\r\n\r\n// Returns, if we already visisted this junction\r\nfunction neverBeenHere(n, currX, currY, ignoreX, ignoreY) {\r\n    // For all neighbours\r\n    for(let elem of n) {\r\n        // If marks at entry of neighbour-path are not 0, return false\r\n        if(getMarks(currX, currY, elem.x, elem.y) > 0 && (elem.x !== ignoreX || elem.y !== ignoreY)) {\r\n            return false;\r\n        }\r\n    }\r\n    // We didn't visit this junction before, return true\r\n    return true;\r\n}\r\n\r\n// Gets marks between two nodes\r\nfunction getMarks(x1, y1, x2, y2) {\r\n    let curr = marks[x1][y1];\r\n    if(x2 < x1) {\r\n        return curr.top;\r\n    } else {\r\n        if(x1 < x2) {\r\n            return curr.bottom;\r\n        } else {\r\n            if(y2 < y1) {\r\n                return curr.left;\r\n            } else {\r\n                return curr.right;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Sets mark between two nodes\r\nfunction mark(x1, y1, x2, y2) {\r\n    let curr = marks[x1][y1];\r\n    let from = marks[x2][y2];\r\n    if(x2 < x1) {\r\n        curr.top++;\r\n        from.bottom++;\r\n    } else {\r\n        if(x1 < x2) {\r\n            curr.bottom++;\r\n            from.top++;\r\n        } else {\r\n            if(y2 < y1) {\r\n                curr.left++;\r\n                from.right++;\r\n            } else {\r\n                curr.right++;\r\n                from.left++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Marks exit node before junction and updates steps\r\nfunction markJunctionEnter(lastX, lastY, x, y) {\r\n    mark(lastX, lastY, x, y); // Mark exit of last path\r\n\r\n    // Push mark to steps\r\n    steps[count].push({\r\n        markedX: lastX,\r\n        markedY: lastY,\r\n        markCount: Object.assign({},marks[lastX][lastY])\r\n    });\r\n\r\n    count++; // Update count because one \"step\"/path has ended\r\n    // Add current junction to steps\r\n    steps[count] = {\r\n        junctionX: x,\r\n        junctionY: y\r\n    };\r\n\r\n    // Update count for next path and create array in steps\r\n    count++;\r\n    steps[count] = [];\r\n}\r\n\r\n// Tremaux-algorithm\r\nfunction tremaux() {\r\n    let found = false; // If we found the exit\r\n\r\n    // While not found\r\n    while(!found) {\r\n        let n = getPathNeighbours(maze, x, y); // Get neighbours\r\n\r\n        // If at the starting-node\r\n        if(lastX === null && lastY === null) {\r\n            // Get random neighbour\r\n            let rand = Math.floor(Math.random() * n.length);\r\n            let next = n[rand];\r\n\r\n            steps[count] = []; // Initialize first step-array\r\n\r\n            // If we are at a junction\r\n            if(n.length > 2) {\r\n                mark(next.x, next.y, x, y); // Mark entry\r\n\r\n                // Push junction to steps\r\n                steps[count] = {\r\n                    junctionX: x,\r\n                    junctionY: y\r\n                };\r\n\r\n                // Increase count\r\n                count++;\r\n                steps[count] = [];\r\n\r\n                // Push marked-coordiantes and markCount to steps\r\n                steps[count].push({\r\n                    markedX: next.x,\r\n                    markedY: next.y,\r\n                    markCount: Object.assign({},marks[next.x][next.y])\r\n                });\r\n            } else {\r\n                // If not at junction, push current element (and null as previous)\r\n                steps[count].push(undefined);\r\n                steps[count].push({\r\n                    x: x,\r\n                    y: y\r\n                });\r\n            }\r\n\r\n            // Set current coordinates to last and next to current\r\n            lastX = x;\r\n            lastY = y;\r\n            x = next.x;\r\n            y = next.y;\r\n        } else if(n.length > 2) {\r\n            // If not at starting node and at junction (more than 2 neighbours)\r\n\r\n            // Mark exit node before junction\r\n            markJunctionEnter(lastX, lastY, x, y);\r\n\r\n            // If never been here\r\n            if(neverBeenHere(n, x, y, lastX, lastY)) {\r\n                // Find node where we were in the step before\r\n                let removeIndex = -1;\r\n                for(let i = 0; i < n.length; i++) {\r\n                    if(n[i].x === lastX && n[i].y === lastY) removeIndex = i;\r\n                }\r\n                n.splice(removeIndex, 1); // Remove the node from neighbours\r\n\r\n                // Choose random neighbour as next node and mark entry\r\n                let rand = Math.floor(Math.random() * n.length);\r\n                let next = n[rand];\r\n\r\n                // If next node is also a junction, don't mark entry (will be done in next step)\r\n                if(getPathNeighbours(maze, next.x, next.y).length < 3) {\r\n                    mark(next.x, next.y, x, y);\r\n                }\r\n\r\n                // Set last and next node\r\n                lastX = x;\r\n                lastY = y;\r\n                x = next.x;\r\n                y = next.y;\r\n\r\n                // Push marked entry to steps\r\n                steps[count].push({\r\n                    markedX: next.x,\r\n                    markedY: next.y,\r\n                    markCount: Object.assign({},marks[next.x][next.y])\r\n                });\r\n            } else {\r\n                // If we have been at this junction before\r\n\r\n                // If last node currently has one mark, enter it\r\n                if(getMarks(x, y, lastX, lastY) === 1) {\r\n                    mark(lastX, lastY, x, y); // Mark node again\r\n\r\n                    // Set last and next node\r\n                    let tempX = lastX;\r\n                    lastX = x;\r\n                    x = tempX;\r\n\r\n                    let tempY = lastY;\r\n                    lastY = y;\r\n                    y = tempY;\r\n\r\n                    // Push marked entry to steps\r\n                    steps[count].push({\r\n                        markedX: lastX,\r\n                        markedY: lastY,\r\n                        markCount: Object.assign({},marks[lastX][lastY])\r\n                    });\r\n                } else {\r\n                    // If last node already has two marks\r\n\r\n                    // Find node with lowest number of marks\r\n                    let minMarks = 2;\r\n                    let minElem = undefined;\r\n                    let temp = null;\r\n                    for(let i = 0; i < n.length; i++) {\r\n                        if((temp = getMarks(n[i].x, n[i].y, x, y)) < minMarks) {\r\n                            minElem = n[i];\r\n                            minMarks = temp;\r\n                        }\r\n                    }\r\n\r\n                    // If every node has 2 marks, an error has occurred\r\n                    if(minMarks > 1 || minElem === undefined) {\r\n                        console.log(\"Error, all nodes at junction \" + x + \":\" + y + \" are already marked twice!\");\r\n                        return false;\r\n                    }\r\n\r\n                    // If next node is also a junction, don't mark entry (will be done in next step)\r\n                    if(getPathNeighbours(maze, minElem.x, minElem.y).length < 3) {\r\n                        mark(minElem.x, minElem.y, x, y); // Mark entry to next path\r\n                    }\r\n\r\n                    // Set last and next node\r\n                    lastX = x;\r\n                    lastY = y;\r\n                    x = minElem.x;\r\n                    y = minElem.y;\r\n\r\n                    // Push marked entry to steps\r\n                    steps[count].push({\r\n                        markedX: minElem.x,\r\n                        markedY: minElem.y,\r\n                        markCount: Object.assign({},marks[minElem.x][minElem.y])\r\n                    });\r\n                }\r\n            }\r\n        } else if(n.length === 2) {\r\n            // If inside a path (exactly two neighbours)\r\n\r\n            // Push current position to steps\r\n            steps[count].push({\r\n                x: x,\r\n                y: y\r\n            });\r\n\r\n            // Chose next neighbour (the one we didn't come from)\r\n            for(let elem of n) {\r\n                if(elem.x !== lastX || elem.y !== lastY) {\r\n                    // Set last and next node\r\n                    lastX = x;\r\n                    lastY = y;\r\n                    x = elem.x;\r\n                    y = elem.y;\r\n                    break;\r\n                }\r\n            }\r\n        } else if(n.length === 1) {\r\n            // If at the end of one path (exactly one neighbour)\r\n\r\n            // Push current position to steps\r\n            steps[count].push({\r\n                x: x,\r\n                y: y\r\n            });\r\n\r\n            // Set last and next node (the one we came from)\r\n            lastX = x;\r\n            lastY = y;\r\n            x = n[0].x;\r\n            y = n[0].y;\r\n        } else {\r\n            // If number of neighbours is lower than 1, shouldn't happen\r\n            console.log(\"Error, no neighbours found\");\r\n            return false;\r\n        }\r\n\r\n        // If we found our destination\r\n        if(x === end[0] && y === end[1]) {\r\n            found = true;\r\n            steps[count].push(null);\r\n            count++;\r\n            steps[count] = {\r\n                end: true\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction getTremaux(m, s, e) {\r\n    maze = m;\r\n    steps = [];\r\n    end = e;\r\n    start = s;\r\n    path = [];\r\n    marks = [];\r\n    count = 0;\r\n\r\n    // Initialize marks with 0 in all directions\r\n    for(let i = 0; i < maze.length; i++) {\r\n        marks[i] = [];\r\n        for (let j = 0; j < maze[i].length; j++) {\r\n            marks[i][j] = {\r\n                top: 0,\r\n                bottom: 0,\r\n                left: 0,\r\n                right: 0\r\n            };\r\n        }\r\n    }\r\n\r\n    // Set starting node and last to null\r\n    x = start[0];\r\n    y = start[1];\r\n    lastX = null;\r\n    lastY = null;\r\n\r\n    let success = tremaux(); // Start search\r\n\r\n    // If an error occured\r\n    if(!success) {\r\n        console.log(\"Error, Tremaux didn't find destination!\");\r\n        return null;\r\n    }\r\n\r\n    // Set current node to last before destination and last to destination\r\n    x = lastX;\r\n    y = lastY;\r\n    lastX = end[0];\r\n    lastY = end[1];\r\n\r\n    // While we are not at our starting node\r\n    while(x !== start[0] || y !== start[1]) {\r\n        if(x === lastX && y === lastY) {\r\n            break;\r\n        }\r\n\r\n        // Push current node to path\r\n        path.push({\r\n            x: x,\r\n            y: y\r\n        });\r\n\r\n        let n = getPathNeighbours(maze, x, y); // Get neighbours\r\n\r\n        // If inside path (exactly two neighbours)\r\n        if(n.length === 2) {\r\n            // Choose the neighbour where we haven't been in the last step\r\n            for(let elem of n) {\r\n                if(elem.x !== lastX || elem.y !== lastY) {\r\n                    lastX = x;\r\n                    lastY = y;\r\n                    x = elem.x;\r\n                    y = elem.y;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            if(n.length === 1) {\r\n                console.log(\"Error while getting path\");\r\n                return null;\r\n            }\r\n\r\n            // If at junction\r\n\r\n            for(let elem of n) {\r\n                let marks = getMarks(x, y, elem.x, elem.y); // Get marks\r\n\r\n                // Choose the neighbour with exactly one mark and where we haven't been in last step\r\n                if(marks === 1 && (elem.x !== lastX || elem.y !== lastY)) {\r\n                    lastX = x;\r\n                    lastY = y;\r\n                    x = elem.x;\r\n                    y = elem.y;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Return values\r\n    return {\r\n        steps: steps,\r\n        path: path\r\n    };\r\n}\r\n\r\nexport { getTremaux };","import {getPathNeighbours, getPathRecursive} from \"../Utils/Functions\";\r\n\r\nlet steps;\r\nlet maze;\r\nlet wasHere;\r\nlet stack;\r\nlet path;\r\nlet end;\r\n\r\n// Get heuristic\r\nfunction getDistance(x, y) {\r\n    return Math.abs(x - end[0]) + Math.abs(y - end[1]);\r\n}\r\n\r\n// Greedy-best-first-search\r\nfunction greedySearch() {\r\n    // While elements in stack\r\n    while(stack.length !== 0) {\r\n        let elem = stack.pop(); // Get first element\r\n        if(wasHere[elem.x][elem.y]) continue; // If visited, continue\r\n\r\n        // If at destination\r\n        if(elem.x === end[0] && elem.y === end[1]) {\r\n            path = getPathRecursive(elem); // Get path\r\n            return;\r\n        }\r\n\r\n        // Set visited and push elem to steps\r\n        wasHere[elem.x][elem.y] = true;\r\n        steps.push(elem);\r\n\r\n        let neighbours = getPathNeighbours(maze, elem.x, elem.y); // Get neighbours\r\n\r\n        // Set distance and parent for all neighbours\r\n        for(let n of neighbours) {\r\n            n.distance = getDistance(n.x, n.y);\r\n            n.parent = elem;\r\n        }\r\n\r\n        // Sort neighbours\r\n        neighbours.sort(function(a, b) {\r\n            return b.distance - a.distance;\r\n        });\r\n\r\n        // Push sorted list to stack\r\n        for(let n of neighbours) {\r\n            stack.push(n);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction getGreedy(m, s, e) {\r\n    maze = m;\r\n    steps = [];\r\n    end = e;\r\n    wasHere = [];\r\n    stack = [];\r\n    path = [];\r\n    for (let i = 0; i < m.length; i++) {\r\n        wasHere[i] = [];\r\n        for (let j = 0; j < m[i].length; j++) {\r\n            wasHere[i][j] = false;\r\n        }\r\n    }\r\n\r\n    stack.push({x: s[0], y: s[1], parent: null}); // Push starting-node to stack\r\n\r\n    greedySearch(); // Start search\r\n\r\n    // Remove starting-node from steps\r\n    steps.shift();\r\n\r\n    // Return values\r\n    return {\r\n        steps: steps,\r\n        path: path\r\n    };\r\n}\r\n\r\nexport { getGreedy };","import {getPathNeighbours, getPathRecursive} from \"../Utils/Functions\";\r\n\r\nlet PriorityQueue = require('priorityqueuejs'); // Using PriorityQueue for A*\r\n\r\nlet steps;\r\nlet maze;\r\nlet wasHere;\r\nlet queue;\r\nlet path;\r\nlet end;\r\n\r\n// Get heuristic\r\nfunction getDistance(x, y) {\r\n    return Math.abs(x - end[0]) + Math.abs(y - end[1]);\r\n}\r\n\r\n// A*-algorithm\r\nfunction aStar() {\r\n    // While PriorityQueue has more elements\r\n    while(!queue.isEmpty()) {\r\n        let elem = queue.deq(); // Get \"best\" element from queue\r\n        if(wasHere[elem.x][elem.y] === true) continue; // Continue, if already visisted\r\n\r\n        // If at destination\r\n        if(elem.x === end[0] && elem.y === end[1]) {\r\n            path = getPathRecursive(elem); // Get path\r\n            return;\r\n        }\r\n\r\n        // Set visited\r\n        wasHere[elem.x][elem.y] = true;\r\n        steps.push(elem);\r\n\r\n        // Get all neighbours\r\n        let neighbours = getPathNeighbours(maze, elem.x, elem.y);\r\n\r\n        // For every neighbours\r\n        for(let n of neighbours) {\r\n            if(wasHere[n.x][n.y] === true) continue; // Continue, if already visited\r\n\r\n            n.distance = elem.distance + 1; // Increase distance (depth of iteration)\r\n            n.heuristic = getDistance(n.x, n.y); // Set heuristic\r\n            n.parent = elem; // Set current node as parent\r\n            queue.enq(n); // Enqueue them\r\n        }\r\n\r\n    }\r\n}\r\n\r\nfunction getAStar(m, s, e) {\r\n    maze = m;\r\n    steps = [];\r\n    end = e;\r\n    wasHere = [];\r\n    path = [];\r\n    for (let i = 0; i < m.length; i++) {\r\n        wasHere[i] = [];\r\n        for (let j = 0; j < m[i].length; j++) {\r\n            wasHere[i][j] = false;\r\n        }\r\n    }\r\n\r\n    // Initialize PriorityQueue\r\n    queue = new PriorityQueue(function(a, b) {\r\n        // Best distance + heuristic is at the front\r\n        return (b.distance + b.heuristic) - (a.distance + a.heuristic);\r\n    });\r\n\r\n    // Enqueue first element (starting node)\r\n    let h = getDistance(s[0], s[1]);\r\n    queue.enq({x: s[0], y: s[1], distance: 0, heuristic: h, parent: null});\r\n\r\n    aStar(); // Start search\r\n\r\n    // Remove starting--node from steps\r\n    steps.shift();\r\n\r\n    // Return values\r\n    return {\r\n        steps: steps,\r\n        path: path\r\n    };\r\n}\r\n\r\nexport { getAStar };","import React from 'react';\nimport Main from \"./Components/Content/Main\";\nimport NavBar from \"./Components/Navigation/NavBar\";\nimport SettingsBar from \"./Components/Settings/SettingsBar\";\nimport Animation from \"./Utils/Animation\";\nimport { createMaze } from \"./Utils/Functions\";\nimport './App.css';\n\nlet animation;\n\nclass App extends React.Component {\n    state = {\n        algorithm: \"a*\", // chosen algorithm, default tremaux\n        algorithmList: [], // list of all algorithms\n        perfectMaze: true, // if maze should be created without loops\n        animationRunning: false, // if the animation is currently running\n        solved: false, // if the maze is solved\n        maze: [], // maze-array\n        saveMaze: [], // saved inital maze to reset animation\n        start: [], // starting point, array has two coordinates as values\n        end: [], // destination, array has two coordinates as values\n        stepCount: 0, // number of steps the algorithm has done\n        /*width: 11,\n        height: 7,/**/\n        /**/width: 151,\n        height: 75,/**/\n        animationSpeed: 500 // speed of the animation, higher values mean faster animation\n    }\n\n    // Sets the algorithm\n    setAlgorithm = (algo) => {\n        if(algo === this.state.algorithm) return; // If current algorithm was chosen, do nothing\n\n        // Reset stepCount and set algorithm to new number\n        this.setState({stepCount: 0});\n        this.setState({algorithm: algo}, () => {\n            let maze = []; // Create new maze\n            let saveMaze = this.state.saveMaze;\n\n            // Copy saveMaze into maze\n            for(let i = 0; i < saveMaze.length; i++) {\n                maze[i] = [];\n                for (let j = 0; j < saveMaze[i].length; j++) {\n                    maze[i][j] = saveMaze[i][j];\n                }\n            }\n\n            // Change algorithm-number in Animation\n            animation.changeAlgorithm(algo, maze);\n\n            // Set new maze and set solved to false\n            this.setState({maze: maze, solved: false});\n        });\n    }\n\n    // Sets starting point\n    setStart = (arr) => {\n        this.setState({start: arr});\n    }\n\n    // Sets destination\n    setEnd = (arr) => {\n        this.setState({end: arr});\n    }\n\n    // Changes speed of the animation\n    changeSpeed = (e) => {\n        if(this.state.animationRunning) return; // Return if animation is currently running\n\n        // Change speed in state and Animation\n        let newSpeed = parseFloat(e.target.value);\n        this.setState({animationSpeed: newSpeed});\n        animation.changeSpeed(newSpeed);\n    }\n\n    // Creates new maze\n    createMaze = () => {\n        let values = createMaze(this.state.height, this.state.width, this.state.perfectMaze); // Calls createMaze function in Functions.js\n\n        // Sets maze, starting point and destination\n        this.setState({\n            maze: values.maze,\n            start: values.start,\n            end: values.end,\n            solved: false\n        }, () => {\n            // Sends new values to Animation\n            animation.changeMaze(values.maze.slice(0), values.steps, values.start, values.end);\n        });\n    }\n\n    // Creates new maze when component has mounted\n    componentDidMount(){\n        animation = new Animation(this.changeState, this.state.algorithm, this.addToStepCount);\n        let algos = animation.getAlgorithmTitles();\n        this.setState({algorithmList: algos});\n        this.createMaze();\n    }\n\n    // ChangeState-function to allow Animation to update the maze\n    changeState = (e) => {\n        this.setState(e);\n    }\n\n    // Change perfectMaze-state\n    setPerfectMaze = (v) => {\n        this.setState({perfectMaze: v});\n    }\n\n    // Click-handler for start/stop animation button\n    animationClick = () => {\n        if(this.state.animationRunning) {\n            // If currently running, end animation\n            animation.endAnimation();\n        } else if(this.state.solved === false) {\n            // If not running and not solved, start animation\n            animation.startAnimation();\n        }\n    }\n\n    // Click-handler for new-maze button\n    newMazeClick = () => {\n        if(this.state.animationRunning) return; // If animation running, do nothing\n\n        // Set stepCount to 0 and create new maze\n        this.setState({stepCount: 0});\n        this.createMaze();\n    }\n\n    // Increases step count\n    addToStepCount = (a) => {\n        this.setState({stepCount: this.state.stepCount + a});\n    }\n\n  render() {\n        return(\n            <div className=\"App\">\n                <NavBar algorithm={this.state.algorithm} algorithmList={this.state.algorithmList} animationRunning={this.state.animationRunning} setAlgorithm={this.setAlgorithm}/>\n                <SettingsBar\n                    solved={this.state.solved}\n                    animationRunning={this.state.animationRunning}\n                    animationSpeed={this.state.animationSpeed}\n                    changeSize={this.changeSize}\n                    newMazeClick={this.newMazeClick}\n                    animationClick={this.animationClick}\n                    changeSpeed={this.changeSpeed}\n                    perfectMaze={this.state.perfectMaze}\n                    setPerfectMaze={this.setPerfectMaze}\n                />\n                <Main\n                    maze={this.state.maze}\n                    algorithm={this.state.algorithm}\n                    steps={this.state.stepCount}\n                />\n                <div id=\"footer\">by <a href=\"http://www.nilslambertz.de\" target=\"_blank\" rel=\"noopener noreferrer\">nils lambertz</a> - <a href=\"https://github.com/nilslambertz/MazeVisualizer\" target=\"_blank\" rel=\"noopener noreferrer\">source code</a></div>\n            </div>\n  )};\n}\n\nexport default App;\n","import {getDfsSteps} from \"../Algorithms/Dfs\";\r\nimport {getDijkstra} from \"../Algorithms/Dijkstra\";\r\nimport {getTremaux} from \"../Algorithms/Tremaux\";\r\nimport {getGreedy} from \"../Algorithms/GreedySearch\";\r\nimport {getAStar} from \"../Algorithms/AStar\";\r\n\r\nclass Animation {\r\n    setState; // SetState-method of App\r\n    maze; // Maze-array\r\n    steps; // Steps to find destination\r\n    path; // Path from start to end\r\n    algorithm; // Current algorithm\r\n    algorithmList; // List of all algorithms\r\n    speed; // Speed of animation\r\n    interval; // Interval-object used to animate\r\n    start; // Starting-node\r\n    end; // Destination-node\r\n    pathAnimating; // If path is currently animating\r\n    pathNumber; // Number used to draw maze-elem as path\r\n    lastElem; // Previous element from steps\r\n    addCount; // addCount-method from App\r\n    getStepFunction; // function to get step-array of current algorithm\r\n    stepFunction; // function to make one step in animation of current algorithm\r\n    pathFunction; // function to draw path\r\n\r\n    constructor(setState, algorithm, addCountFunction) {\r\n        // Initialize values\r\n        this.setState = setState;\r\n        this.speed = 5;\r\n        this.addCount = addCountFunction;\r\n        this.pathNumber = 5;\r\n\r\n        // Create list of algorithms\r\n        this.algorithmList = {\r\n            \"a*\": {\r\n                getSteps: getAStar,\r\n                step: this.defaultStep,\r\n                path: this.pathStepBack\r\n            },\r\n            \"dfs\": {\r\n                getSteps: getDfsSteps,\r\n                step: this.arrayStep,\r\n                path: this.pathStepBack\r\n            },\r\n            \"dijkstra\": {\r\n                getSteps: getDijkstra,\r\n                step: this.arrayStep,\r\n                path: this.pathStepBack\r\n            },\r\n            \"greedy\": {\r\n                getSteps: getGreedy,\r\n                step: this.defaultStep,\r\n                path: this.pathStepBack\r\n            },\r\n            \"tremaux\": {\r\n                getSteps: getTremaux,\r\n                step: this.tremauxStep,\r\n                path: this.pathStepFront\r\n            }\r\n        }\r\n\r\n        this.changeAlgorithm(algorithm);\r\n    }\r\n\r\n    // Returns all algorithm-titles (for NavBar)\r\n    getAlgorithmTitles = () => {\r\n        return Object.keys(this.algorithmList);\r\n    }\r\n\r\n    // Changes algorithm and sets maze if passed as argument\r\n    changeAlgorithm(algo, maze) {\r\n        // Set maze if passed\r\n        if(maze !== undefined) {\r\n            this.maze = maze;\r\n        }\r\n\r\n        // Set functions for new algorithm\r\n        this.getStepFunction = this.algorithmList[algo].getSteps;\r\n        this.pathFunction = this.algorithmList[algo].path;\r\n        this.stepFunction = this.algorithmList[algo].step;\r\n\r\n        // Set algorithm and reset step- and path-array\r\n        this.algorithm = algo;\r\n        this.steps = [];\r\n        this.path = [];\r\n        this.lastElem = undefined;\r\n\r\n        // Reset step-count\r\n        this.setState({stepCount: 0});\r\n    }\r\n\r\n    // Changes the maze\r\n    changeMaze(maze, steps, start, end) {\r\n        // Set maze, start- and end-node and reset step-array\r\n        this.maze = maze;\r\n        this.steps = [];\r\n        this.start = start;\r\n        this.end = end;\r\n        this.lastElem = undefined;\r\n\r\n        // Create saveMaze used when switching algorithms while animation has already started\r\n        let saveMaze = [];\r\n        for(let i = 0; i < maze.length; i++) {\r\n            saveMaze[i] = [];\r\n            for (let j = 0; j < maze[i].length; j++) {\r\n                saveMaze[i][j] = maze[i][j];\r\n            }\r\n        }\r\n        this.setState({maze: this.maze, saveMaze: saveMaze});\r\n    }\r\n\r\n    // Changes speed of animation\r\n    changeSpeed(speed) {\r\n        this.speed = 505 - speed;\r\n    }\r\n\r\n    // Starts animation\r\n    startAnimation() {\r\n        // If we have more steps in our array\r\n        if(this.steps.length !== 0) {\r\n            this.setState({animationRunning: true}); // Set animation to running\r\n            this.animate(this.stepFunction, this.pathFunction); // Start animation\r\n            return true; // Animation has started, return true\r\n        }\r\n\r\n        // If one of the needed functions is not set\r\n        if(this.stepFunction === undefined || this.pathFunction === undefined) {\r\n            alert(\"Error, a needed function is undefined\");\r\n            return false; // Animation couldn't start, return false\r\n        }\r\n\r\n        // Get values from current algorithm\r\n        let values = this.getStepFunction(this.maze.slice(0), this.start, this.end);\r\n\r\n        // If algorithm encountered error\r\n        if(values === null) {\r\n            alert(\"Error, algorithm could not find destination!\");\r\n            return false; // Animation couldn't start, return false\r\n        }\r\n\r\n        // Set path and steps from received values\r\n        this.steps = values.steps;\r\n        this.path = values.path;\r\n\r\n        this.setState({animationRunning: true}); // Animation is now running\r\n        this.animate(this.stepFunction, this.pathFunction); // Start animation\r\n        return true; // Animation has started, return true\r\n    }\r\n\r\n    // Stops animation\r\n    endAnimation(finished, pathFunc) {\r\n        clearInterval(this.interval); // Clear interval\r\n\r\n        // If step-array is empty, animate path\r\n        if (finished) {\r\n            this.animatePath(pathFunc);\r\n        }\r\n\r\n        // If button was pressed and path is not currently animating, set animationRunning to false\r\n        if(this.pathAnimating !== true) {\r\n            this.setState({animationRunning: false});\r\n        }\r\n    }\r\n\r\n    // Animates path step-by-step\r\n    animatePath(func) {\r\n        this.pathAnimating = true; // Set pathAnimating to true\r\n        let int = setInterval(() => {\r\n            // If path-animation is finished\r\n            if(this.path.length === 0) {\r\n                clearInterval(int);\r\n\r\n                // Set states and return\r\n                this.setState({animationRunning: false});\r\n                this.setState({solved: true});\r\n                this.pathAnimating = false;\r\n                return;\r\n            }\r\n            func(); // Call path-drawing function\r\n        }, 10);\r\n    }\r\n\r\n    // Animates next step from path with last element from array\r\n    pathStepBack = () => {\r\n        let elem = this.path.pop();\r\n        this.maze[elem.x][elem.y] = this.pathNumber;\r\n        this.setState({maze: this.maze});\r\n    }\r\n\r\n    // Animates next step from path with first element from array\r\n    pathStepFront = () => {\r\n        let elem = this.path.shift();\r\n        this.maze[elem.x][elem.y] = this.pathNumber;\r\n        this.setState({maze: this.maze});\r\n    }\r\n\r\n    // Animates one step with current algorithm\r\n    animate(step, pathFunc) {\r\n        this.interval = setInterval(() => {\r\n            // If steps is empty\r\n            if (this.steps.length === 0) {\r\n                // End animation and return\r\n                this.endAnimation(true, pathFunc);\r\n                return;\r\n            }\r\n            step(); // Do one step with current algorithm\r\n        }, this.speed);\r\n    }\r\n\r\n    // Does one step\r\n    defaultStep = () => {\r\n        let elem = this.steps.shift(); // Get next element from step-array\r\n        this.maze[elem.x][elem.y] = 4; // Set element to \"searched\"\r\n        this.addCount(1); // Add step\r\n        this.setState({maze: this.maze}); // Set new maze\r\n    }\r\n\r\n    // Does multiple steps at once\r\n    arrayStep = () => {\r\n        let arr = this.steps.shift(); // Get next elements from step-array\r\n\r\n        // For each element, set element to searched\r\n        for(let elem of arr) {\r\n            this.maze[elem.x][elem.y] = 4;\r\n        }\r\n        this.addCount(arr.length); // Add steps\r\n        this.setState({maze: this.maze}); // Set new maze\r\n    }\r\n\r\n    // Does one step with tremaux algorithm\r\n    tremauxStep = () => {\r\n        let arr = this.steps.shift(); // Get next element from step-array\r\n\r\n        // If we found our destination\r\n        if(arr.end === true) {\r\n            let lastArr = this.lastElem; // Get last element\r\n\r\n            // If last element was a junction\r\n            if(lastArr.junctionX !== undefined && lastArr.junctionY !== undefined) {\r\n                this.maze[lastArr.junctionX][lastArr.junctionY] = 0; // Clear last element\r\n            } else {\r\n                // If last element was a path\r\n\r\n                // Clear every element in the path\r\n                for (let i = 1; i < lastArr.length-1; i++) {\r\n                    this.maze[lastArr[i].x][lastArr[i].y] = 0;\r\n                }\r\n\r\n                // Mark entry to path\r\n                let mark = lastArr[0];\r\n                if(mark !== undefined && mark.markedX !== undefined && mark.markedY !== undefined) {\r\n                    this.maze[mark.markedX][mark.markedY] = mark.markCount;\r\n                }\r\n            }\r\n\r\n            // Set new start-, end-node (in case they were overwritten) and maze and return\r\n            this.maze[this.start[0]][this.start[1]] = 2;\r\n            this.maze[this.end[0]][this.end[1]] = 3;\r\n            this.setState({maze: this.maze});\r\n            return;\r\n        }\r\n\r\n        // If we are at a junction\r\n        if(arr.junctionX !== undefined && arr.junctionY !== undefined) {\r\n            // If lastElem exists\r\n            if(this.lastElem !== undefined) {\r\n                let lastArr = this.lastElem;\r\n\r\n                // If last element was a junction too, reset it\r\n                if(lastArr.junctionX !== undefined && lastArr.junctionY !== undefined) {\r\n                    this.maze[lastArr.junctionX][lastArr.junctionY] = 0;\r\n                } else {\r\n                    // If last element was a path\r\n\r\n                    let first = lastArr[0]; // First element of array is number of marks at entry\r\n                    let last = lastArr[lastArr.length - 1]; // Last element of array is number of marks at exit\r\n\r\n                    let x1, x2, y1, y2; // Coordinates of entry and exit\r\n\r\n                    // Set marks on entry\r\n                    if (first !== undefined && last !== undefined && (last.markedX !== first.markedX || last.markedY !== first.markedY)) {\r\n                        if (first.markedX !== undefined && first.markedY !== undefined) {\r\n                            x1 = first.markedX;\r\n                            y1 = first.markedY;\r\n                            this.maze[x1][y1] = first.markCount;\r\n                        }\r\n                    }\r\n\r\n                    // Set marks on exit\r\n                    if (last !== undefined && last.markedX !== undefined && last.markedY !== undefined) {\r\n                        x2 = last.markedX;\r\n                        y2 = last.markedY;\r\n                        this.maze[x2][y2] = last.markCount;\r\n                    }\r\n\r\n                    // Reset all other nodes in path\r\n                    for (let i = 1; i < lastArr.length - 1; i++) {\r\n                        if ((lastArr[i].x !== x1 || lastArr[i].y !== y1) && (lastArr[i].x !== x2 || lastArr[i].y !== y2)) {\r\n                            this.maze[lastArr[i].x][lastArr[i].y] = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set start- and end-nodes in case they were overwritten in the last step\r\n            this.maze[this.start[0]][this.start[1]] = 2;\r\n            this.maze[this.end[0]][this.end[1]] = 3;\r\n\r\n            // Mark current node as searched and add one step\r\n            this.maze[arr.junctionX][arr.junctionY] = 4;\r\n            this.addCount(1);\r\n        } else {\r\n            // If we are inside a path\r\n\r\n            // If last element was a junction, clear element\r\n            if(this.lastElem !== undefined && this.lastElem.junctionX !== undefined && this.lastElem.junctionY !== undefined) {\r\n                this.maze[this.lastElem.junctionX][this.lastElem.junctionY] = 0;\r\n            }\r\n\r\n            // Set start- and end-nodes in case they were overwritten\r\n            this.maze[this.start[0]][this.start[1]] = 2;\r\n            this.maze[this.end[0]][this.end[1]] = 3;\r\n\r\n            // Set all nodes inside path to searched\r\n            for(let i = 1; i < arr.length -1; i++) {\r\n                this.maze[arr[i].x][arr[i].y] = 4;\r\n            }\r\n            this.addCount(arr.length-2); // Add number of nodes to count\r\n        }\r\n        this.lastElem = arr; // Set last element\r\n        this.setState({maze: this.maze}); // Set maze\r\n    }\r\n}\r\n\r\nexport default Animation;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}